/**
 * lock_manager.cpp
 */

#include "concurrency/lock_manager.h"

namespace cmudb {

bool LockManager::LockShared(Transaction *txn, const RID &rid) {


  // 0. 2PL checking condition



  // 1. wait die to decide if txn gets lock, wait for lock or kill itself
  // wait == append “lock request table” 

  // 1.2.1 
  // if asking txn is younger than oldest in existing txns == die

  // 1.2.2
  // if asking txn is older than oldest in existing txns == wait

  // 1.2.3
  // if grant set only shared lock == wait



  // 2. cv wait til all consecutive shared lock requests are granted



  // 3. u() txn granted shared lock + notify other threads


  return false;
}


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////



bool LockManager::LockExclusive(Transaction *txn, const RID &rid) {


  // 1. wait die to decide if txn gets lock, wait for lock or kill itself

  // 1.1 no txn, must be able to get xlock

  // 1.2 wait die == dealing w deadlock == only oldest txn than waiting queue cna get xlock



  // 2. cv wait til all previous lock requests are granted



  // 3. u() txn granted xlock + notify other threads





  return false;
}


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


bool LockManager::LockUpgrade(Transaction *txn, const RID &rid) {



  // 1. find original slock req


  // 2. wait-die of original slock req


  // 3. replace original slock req w xlock

  return false;
}





bool LockManager::Unlock(Transaction *txn, const RID &rid) {


  // 1. if strict 2pl, txn must be in committed or abort state before it can call unlock()



  // 2. if vanilla 2pl 

  // 2.1 txn calls unlock() == growing to shrinking state
  // cannot acquire any lock later, cannot go back to GROWING


  // 2.2 give the lock to next txn waiting on the data object
  // by deleting 1st in waiting queue (txn that is granted the lock)


  // 3. notify the txn in wait queue to get the lock



  return false;
}

} // namespace cmudb
